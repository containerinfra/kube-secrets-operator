package generatedsecret

import (
	"context"

	generatedsecretv1 "github.com/containerinfra/kube-secrets-operator/api/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// cleanup deletes the secrets that were generated by the GeneratedSecret if the DeletionPolicy is set to DeleteOnCleanup
// This function is called when the GeneratedSecret is deleted
func (r *GeneratedSecretReconciler) cleanup(ctx context.Context, generatedSecret *generatedsecretv1.GeneratedSecret) error {
	logger := log.FromContext(ctx)

	if generatedSecret.Spec.DeletionPolicy != generatedsecretv1.DeleteOnCleanup {
		return nil
	}

	for _, secretRef := range generatedSecret.Status.SecretsGeneratedRef.Secrets {
		secret := &corev1.Secret{}
		err := r.Client.Get(ctx, types.NamespacedName{
			Name:      secretRef.Name,
			Namespace: secretRef.Namespace,
		}, secret)
		if err != nil {
			if errors.IsNotFound(err) {
				continue
			}
			logger.Error(err, "failed to get secret for cleanup")
			continue
		}
		if !isSecretOwnedBy(*generatedSecret, *secret) {
			logger.Info("secret not owned by GeneratedSecret, skipping deletion", "secret", secret.Name)
			continue
		}
		err = r.Client.Delete(ctx, secret)
		if err != nil {
			if !errors.IsNotFound(err) {
				logger.Error(err, "failed to delete secret")
				return err
			}
		}
		logger.Info("deleted secret", "secret", secret.Name, "namespace", secret.Namespace)
	}
	return nil
}
